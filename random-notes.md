# Random notes

Compilation of things I learn about the Xbox 360 that could later be put in proper pages.

### Dashlaunch

Dashlaunch exports functions to get and set options. You can import them using `GetModuleHandle("launch.xex")` and `GetProcAddress`, the ordinals for getting and settings option values by name are 9 and 10 respectively. An example of how to import these functions can be found [here](https://github.com/ClementDreptin/XexUtils/blob/master/src/DashLaunch.cpp).

### Hooking

Hooking a function requires storing some instructions of the hooked function in a buffer to later jump to it. This buffer can't be stack or heap allocated because these memory pages aren't executable. Instead, it needs to be allocated as a global variable. On modded consoles, the buffer can be in the `.data` section because page permissions are bypassed and code in the `.data` section can be executed, which is not the case on retail consoles or in emulators. To make sure code in this buffer can be executed in all environments, it is safer to allocated it in the `.text` section of the binary. This can be done using the `__declspec(allocate(".text"))` attribute. Beware that explicitly declaring the section using `#pragma section(".text")` is required even if this section is automatically created by the compiler. An example can be found [here](https://github.com/ClementDreptin/XexUtils/blob/ae8a8b832315678255c00d6a9b967a9136155503/src/Detour.cpp#L10-L15).

When using the debug runtime (`<RuntimeLibrary>MultiThreadedDebug</RuntimeLibrary>` in `.vcxproj` file or the `/MTd` compiler flag), and hooking a title function from a system DLL, you can't call the original function. In this scenario, the jump instructions used to jump back to the original function are allocated by a system thread but used by a title thread. This is fine when using the regular runtime library but the debug one has extra checks that trigger a kernel exception (`stop code 0xf4: CRITICAL_OBJECT_TERMINATION`) and prints "This heap cannot be used by this thread." to the debug output. Those types of exceptions trigger a blue screen on Windows but on Xbox 360 the console just shuts down.

### Hypervisor

The hypervisor exposes functions which allow the kernel and titles to run privileged tasks. These functions can be called using the syscall instructions (`sc` in PowerPC). Modded consoles and consoles exploited with [BadUpdate](https://github.com/grimdoomer/Xbox360BadUpdate) and [FreeMyXe](https://github.com/FreeMyXe/FreeMyXe) have a backdoor installed in `HvxGetVersions` (syscall 0) which allows them to use it as a `memcpy` primitive. An example use of this backdoor can be found [here](https://github.com/ClementDreptin/XexUtils/blob/ae8a8b832315678255c00d6a9b967a9136155503/src/Hypervisor.cpp#L48).

Addresses given to hypervisor functions need to point to memory allocated using `XPhysicalAlloc` and not just `malloc`. Despite its name, `XPhysicalAlloc` still returns a virtual address, which needs to be converted to a physical address using `MmGetPhysicalAddress` and be bitwise OR'd with 0x8000000000000000. A helper function that converts a virtual address to a physical address can be found [here](https://github.com/ClementDreptin/XexUtils/blob/ae8a8b832315678255c00d6a9b967a9136155503/src/Hypervisor.cpp#L14).

### Threads

The [`CreateThread` function](https://learn.microsoft.com/fr-fr/windows/win32/api/processthreadsapi/nf-processthreadsapi-createthread) from the public Win32 API only allows you to create regular threads, and regular threads are attached to the currently running title, which means the thread ends whenever the current title changes.<br>
This is a problem when you create a thread from a system DLL and don't want it to end when you switch games or go back to the dashboard. In order to create a thread that isn't attached to the currently running title, you need to use the `ExCreateThread` function and pass `2` to the `creationFlags` argument. An example of creating a system thread can be found [here](https://github.com/ClementDreptin/Hayzen/blob/2560f7a57434fa73c853fe1f7c87b69caccbd81f/src/Core/Plugin.cpp#L34).<br>
It is also worth noting that creating system threads on the same hardware thread as the title is not possible. This is not a problem when writing a system DLL loaded by Dashlaunch because the Dashlaunch code that loads your DLL already runs on a different hardware thread. But when writing a title, you need to assign the system thread to a different hardware thread manually using the `creationFlags` argument. An example of this process can be found [here](https://github.com/ClementDreptin/X360PluginManager/blob/a2a19591c0aa30e5e455cf7201676eda9c18933e/src/PluginManager.cpp#L143-L147).

### SMC

The SMC (System Management Controller) is the chip responsible for controlling power on the motherboard among other things, a more detailed explanation can be found [here](https://free60.org/Hardware/Console/SMC/). For example, you can set the power LED colors using the `HalSendSMCMessage` function, a helper function that does exactly this can be found [here](https://github.com/ClementDreptin/XexUtils/blob/ae8a8b832315678255c00d6a9b967a9136155503/src/SMC.cpp#L22).

### Sockets

Using sockets on the Xbox 360 without being connected to Xbox Live is pretty complicated. You can't simply use the WinSock API the same way you would on Windows and expect it to work. Anytime you want to create sockets from a system DLL, you need to use internal `NetDll_*` API instead of the `WSA_` functions and the regular socket functions from the C standard library. In general, the `NetDll_*` functions have the same signature as their public version except they take one more argument, the first one, which is the `xnCaller`. An enum with all the possible `xnCaller` values can be found [here](https://github.com/ClementDreptin/XexUtils/blob/ae8a8b832315678255c00d6a9b967a9136155503/src/Kernel.h#L92). For example, you can't use `WSAStartup` as is, you need to use `NetDll_WSAStartupEx` and pass `XNCALLER_SYSAPP` (`2`) to the first argument. To make my life easier, I made a set of macros which allow me to use the `NetDll_*` functions just like the public WinSock API, and these macros can be found [here](https://github.com/ClementDreptin/XexUtils/blob/ae8a8b832315678255c00d6a9b967a9136155503/src/Socket.cpp#L6).

Communication over sockets is encrypted by default on Xbox 360, and encrypting and decrypting requires an active Xbox Live connection, which means encryption needs to be disabled when creating the socket for the communcation to be possible without Xbox Live. Disabling encryption can be set just like any other socket option using `setsockopt` but the flag (`0x5801`) isn't defined in any header. An example of disabling encryption on a socket can be found [here](https://github.com/ClementDreptin/XexUtils/blob/ae8a8b832315678255c00d6a9b967a9136155503/src/Socket.cpp#L71).

### Module

When getting a handle using [`GetModuleHandle`](https://learn.microsoft.com/en-us/windows/win32/api/libloaderapi/nf-libloaderapi-getmodulehandlea) or the `hinstDLL` argument of the [`DllMain` entry point](https://learn.microsoft.com/en-us/windows/win32/dlls/dllmain), the underlying value is a pointer pointing to a [`LDR_DATA_TABLE_ENTRY`](https://github.com/ClementDreptin/XexUtils/blob/ae8a8b832315678255c00d6a9b967a9136155503/src/Kernel.h#L19) structure.

When trying to unload a system module, it is required to set its [`LDR_DATA_TABLE_ENTRY::LoadCount`](https://github.com/ClementDreptin/XexUtils/blob/ae8a8b832315678255c00d6a9b967a9136155503/src/Kernel.h#L32) to 1 before calling `XexUnloadImage` otherwise the module isn't actually unmapped from memory. An example of this process can be found [here](https://github.com/ClementDreptin/X360PluginManager/blob/2e85a7c33b0b0364c1e8ad31348fab9622b606c7/src/main.cpp#L88).

### Filesystem

By default, titles only have access to their own files. For instance, if a title executable lives at `\path\to\game\default.xex`, it has access to the files in `\path\to\game\` but nothing else, and this directory is mapped to the `game:` drive. Titles can get access to other locations on the system but they need to map them to virtual drives first by creating a symbolic link. For example, if a title wants to access the root of the hard drive, for which the NT device path is `\Device\Harddisk0\Partition1\`, it needs to create a symbolic link to it and give it a name. It's a common practice to call it `hdd:` or `hdd1:`. System DLLs also need to create virtual drives if they want to access files using user-mode functions to manipulate files like `fopen` or `std::ifstream`. System DLLs can technically access files without first creating a virtual drive but they need to use the kernel functions to manipulate files, like `NtOpen`, which is more complicated than using the standard library. Note that symbolic links created from titles need to be prefixed with `\??\` but the ones created from system DLLs need to be prefixed with `\System??\`. A helper function to mount an NT device path to a virtual drive can be found [here](https://github.com/ClementDreptin/XexUtils/blob/981df939390f34d8b14568858bb2f03bd3dc7701/src/Xam_.cpp#L121).

### Notifications

Displaying notifications using the `XNotifyQueueUI` function can only be done from title threads, displaying them from system threads isn't normally possible because of a `if (KeGetCurrentProcessType() != PROC_TYPE_SYSTEM)` statement in `XMsgProcessRequest`, and `XNotifyQueueUI` calls `XNotifyQueueUIEx`, which then calls `XMsgProcessRequest`. This restriction can be removed by writing the 16-bit unsigned integer `0x4800` at `0x816A3158` (on kernel 17559), which turns `bne cr6, loc_816A3174` into `b loc_816A3174`, which basically bypasses the `if` statement. A complete example of this process, including restoration of the initial instruction, can be found [here](https://github.com/ClementDreptin/Hayzen/blob/28fe645ec1e45d6ab642ee6e683bbef97965b8df/src/Modules/NotificationPatcher.cpp).
